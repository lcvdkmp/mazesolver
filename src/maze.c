/*
 * File: maze.c
 *
 * Functions that work with a maze
 *
 * Author: Luca van der Kamp
 * Date: 2014-02-28
 */

#include <stdlib.h>
#include <stdio.h>
#include "mazedef.h"
#include "walkerdef.h"

/* is set to 1 when a non-fatal error is generated by the maze parser */
int mazewarn = 0;

maze_t* init_maze(int r, int c) {
    maze_t *m = (maze_t *)malloc(sizeof(maze_t));
    m->r = r;
    m->c = c;
    m->start.x = 0;
    m->start.y = 0;

    m->maze = malloc(sizeof(char *) * r);

    for (int i = 0; i < r; i++)
        m->maze[i] = malloc(sizeof(char) * c);

    return m;
}


/*
 * Parse start position of maze m at (col, row).
 * Parse triggered by character c.
 * start_defined keeps track of whether a start position was previously found.
 */
int parse_start(maze_t* m, int col, int row, char *c, int *start_defined) {
    /* give a warning when multiple starts are defined */
    if (!*start_defined) {
        m->start.x = col;
        m->start.y = row;
        *start_defined = 1;
        return 1;
    } else {
        fprintf(stderr,
                "Redefinition of start position"
                " at %i, %i\n",
                col, row);
        fprintf(stderr, "Treating as open space!\n");
        fprintf(stderr,
                "Previous declaration here:"
                " %i, %i!\n",
                m->start.x, m->start.y);
        *c = OPEN;
        mazewarn = 1;
        return 0;
    }
}

maze_t* read_maze(const char *fname) {
    FILE *f = fopen(fname, "r");
    if (!f)
        return NULL;

    /* get header info */
    int rows, columns;
    fscanf(f, "%i,%i\n", &rows, &columns);
    fprintf(stderr, "setting maze dimensions to: %i, %i\n", rows, columns);

    maze_t *m = init_maze(rows, columns);
    char buffer[BLOCK_SIZE + 1];

    /* current column that is being filled */
    int cc = 0;
    /* current row that is being filled */
    int cr = 0;
    /* number of characters read */
    int l = 0;
    /* whether a start or exit has been found */
    int start, exit;
    start = exit = 0;

    while ((l = fread(buffer, 1, BLOCK_SIZE, f))) {
        /* buffer must be a string for debug output */
        buffer[l] = '\0';
        char *c = buffer;

        for (int i = 0; i < l; i++, c++) {
            if(*c == '\n') {
                cr++;
                cc = 0;
                continue;
            }

            /* check whether we are out of bounds */
            if (cc >= columns || cr >= rows ) {
                fprintf(stderr, "Out of bounds (%i, %i). Maze dimensions %i, %i\n",
                        cc, cr, columns, rows);
                goto fail;
            }

            /* TODO */
            if (!val_maze_char(*c)) {
                fprintf(stderr, "Invalid character (%c) found at %i, %i\n", *c,
                        cr, cc);
                goto fail;
            }

            /* check if all borders of the maze are walls */
            if ((cr == 0 || cr == m->c || cc == 0 || cc == m->c) && *c != WALL) {
                fprintf(stderr, "Border is not a wall at %i, %i\n", cc, cr);
                goto fail;
            }

            /* parse special characters */
            switch (*c) {
            case START:
                parse_start(m, cc, cr, c, &start);
                break;

            case EXIT:
                exit = 1;
                m->exit.x = cc;
                m->exit.y = cr;
                break;
            }
            /* parse any other character */
            m->maze[cr][cc] = *c;
            cc++;
        }
    }
    if (!start)
        goto fail;
    fclose(f);
    return m;

fail:
    /* a fatal error occured */
    fclose(f);
    cleanup_maze(m);
    return NULL;
}

int val_maze_char(char c) {
    /* the valid maze characters */
    static char valmazec[] = {
        WALL,
        START,
        EXIT,
        OPEN,
        '\n',
        EOF,
        '\0',
    };

    char *check = valmazec;
    while (check) {
        if (c == *check)
            return 1;
        check++;
    }
    return 0;
}

char tile_dir(maze_t *m, point_t p, direction_t dir) {
    trans_point_dir(&p, dir);

    if (p.x < 0 || p.y < 0 || p.x >= m->c  || p.y >= m->r )
        return 0;
    return m->maze[p.y][p.x];
}

void cleanup_maze(maze_t *maze) {
    if (maze) {
        for(int i = 0; i < maze->r; i++)
            free(maze->maze[i]);
        free(maze->maze);
        free(maze);
    }
}
